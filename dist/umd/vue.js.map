{"version":3,"file":"vue.js","sources":["../../src/observer/index.js","../../src/state.js","../../src/init.js","../../src/index.js"],"sourcesContent":["\r\n//观测数据可能有观测数组啊观测对象啊还有一些其他的方法,所以写个类比较好\r\nclass Obsereve{\r\n    constructor(value){\r\n        //使用defineProperty 重新定义属性\r\n\r\n       this.walk(value)\r\n        \r\n    }\r\n    walk(data){\r\n        let keys = Object.keys(data);\r\n        keys.forEach((key)=>{\r\n            defineReactive(data,key,data[key])\r\n        })\r\n    }\r\n}\r\n\r\nfunction defineReactive(data,key,value){\r\n    /* 这里为什么不直接data[key]= newvalue?如果这样会死循环的\r\n    因为key的值一变就触发set,set里面又改key的值,所以需要借住第三方变量 */\r\n   /*  如果观测`的value还是一个对象,那就观测不到了,\r\n    所以如果是对象我们需要再执行一次observe */\r\n    //!默认弄个数据会递归去用defineProperty进行拦截,性能不太好,所以vue3使用了proxy\r\n    observe(value)\r\n    Object.defineProperty(data,key,{\r\n        get(){\r\n            console.log('读入');\r\n            \r\n            return value\r\n        },\r\n        set(newValue){\r\n            console.log('修改');\r\n            \r\n            if(newValue == value){\r\n                return\r\n            }\r\n            //?用户有可能把新的值也设为了对象,如果是对象我们也要observe\r\n            observe(newValue)\r\n            value = newValue\r\n        }\r\n    })\r\n}\r\nexport function observe(data){\r\n\r\n\r\n    //有可能误传,要判断只有对象才继续执行\r\n    if(typeof data !=='object' || data ==null){\r\n        return\r\n    }\r\n    return new Obsereve(data)\r\n    \r\n    \r\n}","import { observe } from \"./observer/index\";\r\n\r\nexport function initState(vm){\r\n    const opts = vm.$options;\r\n    //这几个初始化是有顺序的,因为要判断xx和xx重名了怎么办的情况\r\n    if(opts.props){\r\n        initProps(vm)\r\n    }\r\n    if(opts.methods){\r\n        initMethods(vm)\r\n    }\r\n    if(opts.data){\r\n        initData(vm)\r\n    }\r\n    if(opts.computed){\r\n        initComputed(vm)\r\n    }\r\n    if(opts.watch){\r\n        initWatch(vm)\r\n    }\r\n    \r\n}\r\n\r\nfunction initProps(){}\r\nfunction initMethods(){}\r\nfunction initData(vm){\r\n    //数据初始化\r\n    let data = vm.$options.data;\r\n    //data有可能是对象也有可能是函数要特殊处理\r\n    //但是vm不能得到data所以加一个vm._data\r\n    vm._data = data = typeof data =='function'?data.call(vm):data;\r\n    //数据劫持方案 对象Object.defineProperty\r\n    //数组 是单独处理的\r\n    //但是要注意这个data是不可能是数组,数组只有在对象里面嵌套数组,所以这里不需要判断是对象还是数组\r\n    observe(data);\r\n    \r\n    \r\n}\r\nfunction initComputed(){}\r\nfunction initWatch(){}","import { initState } from \"./state\";\r\n\r\n//!只要是插件就一定是一个函数\r\nexport function initMixin(Vue){\r\n    Vue.prototype._init = function(options){\r\n      \r\n        //vue会把拿到的option都放到实例的$option上\r\n        const vm = this;\r\n        vm.$options = options\r\n\r\n        //初始化状态(将数据做一个初始化的劫持 当我改变数据时应该更新视图)\r\n        //vue组件中有很多状态 data props watch computed\r\n        initState(vm)\r\n\r\n\r\n\r\n\r\n        //vue里面核心特性.响应式数据原理\r\n        //Vue是一个参考MVVM的框架\r\n       /*  数据变化视图会更新,视图变化数据会受影响 (MVVM) 不能跳过数据直接去更新视图\r\n        但是vue可以通过$ref所以说vue只是参考MVVM */\r\n    }\r\n}","//第一步初始化option,但是方法很多,所以要把方法写在原型上(主要是组件可能会用到)\r\n\r\nimport {initMixin} from './init.js'\r\n\r\nfunction Vue(option){\r\n    this._init(option)// 入口方法,初始化操作\r\n}\r\n\r\n//写成一个个的插件进行对原型的扩展\r\ninitMixin(Vue)\r\n\r\n\r\nexport default Vue"],"names":["Obsereve","value","walk","data","keys","Object","forEach","key","defineReactive","observe","defineProperty","get","console","log","set","newValue","initState","vm","opts","$options","props","methods","initData","computed","watch","_data","call","initMixin","Vue","prototype","_init","options","option"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EACA;MACMA;EACF,oBAAYC,KAAZ,EAAkB;EAAA;;EACd;EAED,SAAKC,IAAL,CAAUD,KAAV;EAEF;;;;aACD,cAAKE,IAAL,EAAU;EACN,UAAIC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYD,IAAZ,CAAX;EACAC,MAAAA,IAAI,CAACE,OAAL,CAAa,UAACC,GAAD,EAAO;EAChBC,QAAAA,cAAc,CAACL,IAAD,EAAMI,GAAN,EAAUJ,IAAI,CAACI,GAAD,CAAd,CAAd;EACH,OAFD;EAGH;;;;;;EAGL,SAASC,cAAT,CAAwBL,IAAxB,EAA6BI,GAA7B,EAAiCN,KAAjC,EAAuC;EACnC;EACJ;;EACG;EACH;EACI;EACAQ,EAAAA,OAAO,CAACR,KAAD,CAAP;EACAI,EAAAA,MAAM,CAACK,cAAP,CAAsBP,IAAtB,EAA2BI,GAA3B,EAA+B;EAC3BI,IAAAA,GAD2B,iBACtB;EACDC,MAAAA,OAAO,CAACC,GAAR,CAAY,IAAZ;EAEA,aAAOZ,KAAP;EACH,KAL0B;EAM3Ba,IAAAA,GAN2B,eAMvBC,QANuB,EAMd;EACTH,MAAAA,OAAO,CAACC,GAAR,CAAY,IAAZ;;EAEA,UAAGE,QAAQ,IAAId,KAAf,EAAqB;EACjB;EACH,OALQ;;;EAOTQ,MAAAA,OAAO,CAACM,QAAD,CAAP;EACAd,MAAAA,KAAK,GAAGc,QAAR;EACH;EAf0B,GAA/B;EAiBH;;EACM,SAASN,OAAT,CAAiBN,IAAjB,EAAsB;EAGzB;EACA,MAAG,QAAOA,IAAP,MAAe,QAAf,IAA2BA,IAAI,IAAG,IAArC,EAA0C;EACtC;EACH;;EACD,SAAO,IAAIH,QAAJ,CAAaG,IAAb,CAAP;EAGH;;EClDM,SAASa,SAAT,CAAmBC,EAAnB,EAAsB;EACzB,MAAMC,IAAI,GAAGD,EAAE,CAACE,QAAhB,CADyB;;EAGzB,MAAGD,IAAI,CAACE,KAAR,EAAc;;EAGd,MAAGF,IAAI,CAACG,OAAR,EAAgB;;EAGhB,MAAGH,IAAI,CAACf,IAAR,EAAa;EACTmB,IAAAA,QAAQ,CAACL,EAAD,CAAR;EACH;;EACD,MAAGC,IAAI,CAACK,QAAR,EAAiB;;EAGjB,MAAGL,IAAI,CAACM,KAAR,EAAc;EAIjB;;EAID,SAASF,QAAT,CAAkBL,EAAlB,EAAqB;EACjB;EACA,MAAId,IAAI,GAAGc,EAAE,CAACE,QAAH,CAAYhB,IAAvB,CAFiB;EAIjB;;EACAc,EAAAA,EAAE,CAACQ,KAAH,GAAWtB,IAAI,GAAG,OAAOA,IAAP,IAAc,UAAd,GAAyBA,IAAI,CAACuB,IAAL,CAAUT,EAAV,CAAzB,GAAuCd,IAAzD,CALiB;EAOjB;EACA;;EACAM,EAAAA,OAAO,CAACN,IAAD,CAAP;EAGH;;EClCM,SAASwB,SAAT,CAAmBC,GAAnB,EAAuB;EAC1BA,EAAAA,GAAG,CAACC,SAAJ,CAAcC,KAAd,GAAsB,UAASC,OAAT,EAAiB;EAEnC;EACA,QAAMd,EAAE,GAAG,IAAX;EACAA,IAAAA,EAAE,CAACE,QAAH,GAAcY,OAAd,CAJmC;EAOnC;;EACAf,IAAAA,SAAS,CAACC,EAAD,CAAT,CARmC;EAcnC;;EACD;EACP;EACK,GAjBD;EAkBH;;ECtBD;;EAIA,SAASW,GAAT,CAAaI,MAAb,EAAoB;EAChB,OAAKF,KAAL,CAAWE,MAAX,EADgB;;EAEnB;;;EAGDL,SAAS,CAACC,GAAD,CAAT;;;;;;;;"}