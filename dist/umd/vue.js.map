{"version":3,"file":"vue.js","sources":["../../src/observer/array.js","../../src/observer/index.js","../../src/state.js","../../src/init.js","../../src/index.js"],"sourcesContent":["import { observe } from \".\"\r\n\r\n//拿到数组原型上的方法(原来的方法)\r\nlet oldArrayProtoMethods = Array.prototype\r\n\r\n//继承一下\r\n//!这样假如调用的话就会先找本身的,没有的再找回数组的方法\r\nexport let arrayMethods = Object.create(oldArrayProtoMethods)\r\n\r\nlet methods = ['push','pop','sort','unshift','reserve','splice','shift']\r\n\r\n\r\nmethods.forEach((method)=>{\r\n    arrayMethods[method]=function(...args){\r\n        // 虽然重写但是方法还是需要调用原来的,只是添加了数据后要对数据进行响应式处理\r\n        console.log('数组方法被调用了');\r\n       const result =  oldArrayProtoMethods[method].apply(this,args)\r\n       let inserted;\r\n       //!这里如果数组增加的数据是对象的话,也需要进行observe\r\n       switch(method){\r\n           case 'push':\r\n           case 'unshift'://这2方法都是追加 追加应该都被劫持才对\r\n            inserted = args\r\n           break;\r\n            case 'splice':\r\n                //如果是添加 参数都是放在第三位置的 所以是slice(2)开始截取到最后\r\n                inserted = args.slice[2]\r\n           default:\r\n               break\r\n       }\r\n       if(inserted){\r\n           //虽然观察了,但是我要怎么拿到observeArray?\r\n           //当前的this对应的就是array.js文件里面的Observe里的value 谁调用this就是谁\r\n           //!那我们把要用的方法挂载到value上就可以了,可以用object.defineProperty自定义一个ob属性,且还可以用来观察一个对象是否被观测过\r\n           this.__ob__.observeArray(inserted)\r\n       }\r\n       return result;  //这个return是为了和原来方法一样,原来也是有return值的\r\n    }\r\n})\r\n\r\n","import { arrayMethods } from \"./array\";\r\n\r\n//观测数据可能有观测数组啊观测对象啊还有一些其他的方法,所以写个类比较好\r\nclass Obsereve{\r\n    constructor(value){\r\n        //使用defineProperty 重新定义属性\r\n\r\n\r\n        //判断一个对象是否被观测过看他是否有_ob_属性\r\n        //但是如果直接value.__ob__ = this 这样就出错了,因为会进入下面的循环会死循环\r\n        //所以使用define特性设置不可枚举\r\n        Object.defineProperty(value,'__ob__',{\r\n            enumerable:false,//不能被枚举,就是不能被循环出来\r\n            configurable:false,//不能被删除\r\n            value:this\r\n        })\r\n        if(Array.isArray(value)){\r\n            //我们希望调用push pop shift unshift splice sort reserve重写\r\n            //简称函数劫持、切片编程\r\n            //!这里把value的__proto__改了,但是其实因为继承了数组的方法,不会有影响的,只是重写了一些方法\r\n           value.__proto__ =  arrayMethods\r\n           //如果数组里面有对象还需要进行observe\r\n           this.observeArray(value)\r\n        }else{\r\n            this.walk(value)\r\n        }\r\n       \r\n        \r\n    }\r\n    //对数组的每一项进行观测\r\n    observeArray(value){\r\n        value.forEach((item)=>{\r\n            observe(item)\r\n        })\r\n    }\r\n    walk(data){\r\n        let keys = Object.keys(data);\r\n        keys.forEach((key)=>{\r\n            defineReactive(data,key,data[key])\r\n        })\r\n    }\r\n}\r\n\r\nfunction defineReactive(data,key,value){\r\n    /* 这里为什么不直接data[key]= newvalue?如果这样会死循环的\r\n    因为key的值一变就触发set,set里面又改key的值,所以需要借住第三方变量 */\r\n   /*  如果观测`的value还是一个对象,那就观测不到了,\r\n    所以如果是对象我们需要再执行一次observe */\r\n    //!默认弄个数据会递归去用defineProperty进行拦截,性能不太好,所以vue3使用了proxy\r\n    observe(value)\r\n    Object.defineProperty(data,key,{\r\n        get(){\r\n            console.log('读入');\r\n            \r\n            return value\r\n        },\r\n        set(newValue){\r\n            console.log('修改');\r\n            \r\n            if(newValue == value){\r\n                return\r\n            }\r\n            //?用户有可能把新的值也设为了对象,如果是对象我们也要observe\r\n            observe(newValue)\r\n            value = newValue\r\n        }\r\n    })\r\n}\r\nexport function observe(data){\r\n\r\n\r\n    //有可能误传,要判断只有对象才继续执行\r\n    if(typeof data !=='object' || data ==null){\r\n        return data\r\n    }\r\n    //已经被观察过了 不必进入判断,增加点性能\r\n    if(data.__ob__){\r\n        return data\r\n    }\r\n    return new Obsereve(data)\r\n    \r\n    \r\n}","import { observe } from \"./observer/index\";\r\n\r\nexport function initState(vm){\r\n    const opts = vm.$options;\r\n    //这几个初始化是有顺序的,因为要判断xx和xx重名了怎么办的情况\r\n    if(opts.props){\r\n        initProps(vm)\r\n    }\r\n    if(opts.methods){\r\n        initMethods(vm)\r\n    }\r\n    if(opts.data){\r\n        initData(vm)\r\n    }\r\n    if(opts.computed){\r\n        initComputed(vm)\r\n    }\r\n    if(opts.watch){\r\n        initWatch(vm)\r\n    }\r\n    \r\n}\r\n\r\nfunction initProps(){}\r\nfunction initMethods(){}\r\nfunction initData(vm){\r\n    //数据初始化\r\n    let data = vm.$options.data;\r\n    //data有可能是对象也有可能是函数要特殊处理\r\n    //但是vm不能得到data所以加一个vm._data\r\n    vm._data = data = typeof data =='function'?data.call(vm):data;\r\n    //数据劫持方案 对象Object.defineProperty\r\n    //数组 是单独处理的\r\n    //但是要注意这个data是不可能是数组,数组只有在对象里面嵌套数组,所以这里不需要判断是对象还是数组\r\n    observe(data);\r\n    \r\n    \r\n}\r\nfunction initComputed(){}\r\nfunction initWatch(){}","import { initState } from \"./state\";\r\n\r\n//!只要是插件就一定是一个函数\r\nexport function initMixin(Vue){\r\n    Vue.prototype._init = function(options){\r\n      \r\n        //vue会把拿到的option都放到实例的$option上\r\n        const vm = this;\r\n        vm.$options = options\r\n\r\n        //初始化状态(将数据做一个初始化的劫持 当我改变数据时应该更新视图)\r\n        //vue组件中有很多状态 data props watch computed\r\n        initState(vm)\r\n\r\n\r\n\r\n\r\n        //vue里面核心特性.响应式数据原理\r\n        //Vue是一个参考MVVM的框架\r\n       /*  数据变化视图会更新,视图变化数据会受影响 (MVVM) 不能跳过数据直接去更新视图\r\n        但是vue可以通过$ref所以说vue只是参考MVVM */\r\n    }\r\n}","//第一步初始化option,但是方法很多,所以要把方法写在原型上(主要是组件可能会用到)\r\n\r\nimport {initMixin} from './init.js'\r\n\r\nfunction Vue(option){\r\n    this._init(option)// 入口方法,初始化操作\r\n}\r\n\r\n//写成一个个的插件进行对原型的扩展\r\ninitMixin(Vue)\r\n\r\n\r\nexport default Vue"],"names":["oldArrayProtoMethods","Array","prototype","arrayMethods","Object","create","methods","forEach","method","console","log","args","result","apply","inserted","slice","__ob__","observeArray","Obsereve","value","defineProperty","enumerable","configurable","isArray","__proto__","walk","item","observe","data","keys","key","defineReactive","get","set","newValue","initState","vm","opts","$options","props","initData","computed","watch","_data","call","initMixin","Vue","_init","options","option"],"mappings":"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"}